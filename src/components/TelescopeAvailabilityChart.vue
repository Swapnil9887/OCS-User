<template>
  <div class="telescopeAvailability">
    {{ error }}
    <table v-show="sortedTelescopes.length" class="availability_chart table table-bordered table-sm">
      <thead class="thead-default">
        <th>Telescope</th>
        <th v-for="(dateLabel, dataLabelIdx) in dateLabels" :key="dataLabelIdx">
          {{ dateLabel }}
        </th>
      </thead>
      <tbody class="tbody-default">
        <tr v-for="(telescope, telescopeIdx) in sortedTelescopes" :key="telescopeIdx">
          <td>{{ telescope | readableSiteName }}</td>
          <td
            v-for="(availabilities, availabilitiesIdx) in availabilityData[telescope]"
            :key="availabilitiesIdx"
            :class="[availabilityToColor(availabilities[1])]"
          >
            {{ (availabilities[1] * 100).toFixed() }}
          </td>
        </tr>
      </tbody>
    </table>
    <p v-show="!sortedTelescopes.length && !error" class="text-center">
      <i class="fa fa-spin fa-spinner" />
    </p>
  </div>
</template>
<script>
import _ from 'lodash';
import $ from 'jquery';

import { siteCodeToName, observatoryCodeToNumber, telescopeCodeToName } from '@/utils.js';

export default {
  name: 'TelescopeAvailabilityChart',
  filters: {
    readableSiteName: function(value) {
      let split_string = value.split('.');
      let site = split_string[0];
      let observatory = split_string[1];
      let tel = split_string[2];
      return siteCodeToName[site] + ' ' + telescopeCodeToName[tel] + ' ' + observatoryCodeToNumber[observatory];
    }
  },
  data: function() {
    return {
      availabilityData: {},
      minDate: null,
      maxDate: null,
      dateLabels: [],
      sortedTelescopes: [],
      error: ''
    };
  },
  computed: {
    observationPortalApiUrl: function() {
      return this.$store.state.urls.observationPortalApi;
    }
  },
  watch: {
    availabilityData: function() {
      this.minDate = new Date(8640000000000000);
      this.maxDate = new Date(-8640000000000000);
      for (let telescope in this.availabilityData) {
        if (this.availabilityData[telescope].length > 0) {
          let firstDate = new Date(this.availabilityData[telescope][0][0]);
          if (firstDate < this.minDate) {
            this.minDate = firstDate;
          }
          let lastDate = new Date(_.last(this.availabilityData[telescope])[0]);
          if (lastDate > this.maxDate) {
            this.maxDate = lastDate;
          }
          this.sortedTelescopes.push(telescope);
        }
      }
      this.sortedTelescopes.sort();
      this.dateLabels = [];
      let currentDate = new Date(this.minDate);
      while (currentDate <= this.maxDate) {
        let days_ago = Math.ceil((this.maxDate.getTime() - currentDate.getTime()) / (1000 * 3600 * 24));
        if (days_ago === 0) this.dateLabels.push('Today');
        else if (days_ago === 1) this.dateLabels.push('-' + days_ago + ' day');
        else this.dateLabels.push('-' + days_ago + ' days');
        currentDate.setDate(currentDate.getDate() + 1);
      }
    }
  },
  created: function() {
    let that = this;
    let endDate = new Date();
    let startDate = new Date(endDate);
    startDate.setDate(startDate.getDate() - 3);
    startDate.setHours(0);
    startDate.setMinutes(0);
    startDate.setSeconds(0);
    startDate.setMilliseconds(0);
    $.getJSON(
      this.observationPortalApiUrl + '/api/telescope_availability/?start=' + startDate.toISOString() + '&end=' + endDate.toISOString(),
      function(data) {
        if (data === 'ConnectionError') {
          that.error = 'Unable to retrieve history';
          return;
        }
        that.availabilityData = data;
      }
    );
  },
  methods: {
    availabilityToColor: function(availability) {
      if (availability > 0.75) return 'table-success';
      else if (availability > 0.25) return 'table-warning';
      return 'table-danger';
    }
  }
};
</script>
